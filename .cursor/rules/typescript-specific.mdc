description: TypeScript development standards and type safety rules
globs:
  - **/*.ts
  - **/*.tsx
alwaysApply: false
---

# TypeScript Development Standards

## Development Workflow
**IMPORTANT: All TypeScript operations MUST be run using Taskfile commands.**
- Use `task dev:type-check` to run TypeScript type checking
- Use `task dev:lint` to check code quality
- Use `task dev:format` to format code
- Use `task database:db-types` to generate types from database schema

## Type Safety
- Always use strict TypeScript configuration
- Define interfaces for all data structures
- Use type guards for runtime type checking
- Avoid type assertions (`as`) when possible
- Use discriminated unions for complex state

## Zod Integration
- Create Zod schemas for all data validation
- Use `z.infer<typeof schema>` for type inference
- Validate all external data (API responses, user inputs)
- Create specific validators for each domain

## Example Patterns

### Validation Schema
```typescript
// userProfileValidator.ts
import { z } from 'zod'

export const userProfileSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(100),
  email: z.string().email(),
  avatarUrl: z.string().url().optional()
})

export type UserProfile = z.infer<typeof userProfileSchema>
```

### Operation Function
```typescript
// userProfileUpdater.ts
import { userProfileSchema, type UserProfile } from './userProfileValidator'

export async function updateUserProfile(data: UserProfile): Promise<UserProfile> {
  const validated = userProfileSchema.parse(data)
  // Implementation here
  return validated
}
```

## File Organization
- One schema per file for complex validations
- Group related types in dedicated type files
- Export types from barrel files (`index.ts`)
- Use consistent naming: `[Entity][Action]Validator.ts`

## Error Handling
- Use Result types for operations that can fail
- Implement proper error boundaries
- Provide meaningful error messages
- Log errors with appropriate context
---
